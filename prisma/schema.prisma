// Schéma Prisma amélioré avec optimisations et bonnes pratiques

generator client {
  provider = "prisma-client-js"
  output   = "../lib/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================
//                        AUTHENTIFICATION
// ============================================================

model User {
  id            String  @id @default(cuid())
  name          String
  email         String
  emailVerified Boolean @default(false) // Valeur par défaut
  image         String?
  slug          String? @unique // Pour les URLs SEO-friendly

  // Timestamps avec valeurs par défaut
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  sessions     Session[]
  accounts     Account[]
  profile      Profile?
  badges       UserBadge[]
  consent      UserConsent?
  gdprRequests GDPRRequest[]
  posts        Post[] // Ajout pour le contenu utilisateur

  // Modération améliorée
  role       Role       @default(user) // Enum en majuscules
  status     UserStatus @default(ACTIVE) // Nouveau : statut utilisateur
  banned     Boolean?   @default(false)
  banReason  String?
  banExpires DateTime?
  bannedBy   String? // ID de l'admin qui a banni

  // Sécurité
  lastLoginAt  DateTime?
  lastLoginIp  String?
  failedLogins Int       @default(0)
  lockedUntil  DateTime?

  // RGPD et confidentialité
  dataRetention DateTime? // Date d'expiration des données
  deletedAt     DateTime? // Soft delete
  places         Place[]            @relation("PlaceOwner")
  reviews        Review[]
  favorites      Favorite[]
  placeClaims    PlaceClaim[]
  events         Event[]            @relation("EventOrganizer")
  eventParticipations EventParticipant[]
  eventReminders EventReminder[]
  newsletterCampaigns NewsletterCampaign[]
  newsletterAttachments NewsletterAttachment[]

  // Index pour les performances
  @@unique([email])
  @@index([email])
  @@index([slug])
  @@index([role])
  @@index([status])
  @@index([createdAt])
  @@map("user")
}

model Session {
  id        String   @id @default(cuid())
  expiresAt DateTime
  token     String
  createdAt DateTime @default(now()) // Valeur par défaut
  updatedAt DateTime @updatedAt
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Sécurité avancée
  impersonatedBy String?
  deviceInfo     Json? // Informations sur l'appareil
  isActive       Boolean   @default(true)
  revokedAt      DateTime?

  @@unique([token])
  @@index([userId])
  @@index([expiresAt])
  @@index([isActive])
  @@map("session")
}

model Account {
  id                    String    @id @default(cuid())
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String? // Hash du mot de passe
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  // Métadonnées de connexion
  firstLoginAt DateTime?
  lastUsedAt   DateTime?

  @@unique([providerId, accountId]) // Contrainte composite
  @@index([userId])
  @@index([providerId])
  @@map("account")
}

model Verification {
  id         String           @id @default(cuid())
  identifier String // Email ou téléphone
  value      String // Code ou token
  type       VerificationType @default(EMAIL) // Type de vérification
  expiresAt  DateTime
  used       Boolean          @default(false) // Marquer comme utilisé
  attempts   Int              @default(0) // Nombre de tentatives
  createdAt  DateTime         @default(now())
  updatedAt  DateTime         @updatedAt

  @@index([identifier, type])
  @@index([expiresAt])
  @@map("verification")
}

// ============================================================
//                        PROFIL ET BADGES
// ============================================================

model Profile {
  id        String  @id @default(cuid())
  firstname String?
  lastname  String?
  bio       String?
  phone     String?
  address   String?
  socials   Json? // Réseaux sociaux

  // Préférences utilisateur
  language String? @default("fr")
  timezone String? @default("Europe/Paris")
  theme    Theme?  @default(SYSTEM)

  // Visibilité et confidentialité
  isPublic  Boolean @default(true)
  showEmail Boolean @default(false)
  showPhone Boolean @default(false)

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@map("profile")
}

model Badge {
  id          String        @id @default(cuid())
  title       String
  description String
  iconUrl     String?
  color       String?       @default("#3B82F6") // Couleur du badge
  category    BadgeCategory @default(GENERAL) // Catégorie de badge
  rarity      BadgeRarity   @default(COMMON) // Rareté
  isActive    Boolean       @default(true) // Peut être désactivé

  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt
  users     UserBadge[]

  @@index([category])
  @@index([isActive])
  @@map("badge")
}

model UserBadge {
  id       String   @id @default(cuid())
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId   String
  badge    Badge    @relation(fields: [badgeId], references: [id], onDelete: Cascade)
  badgeId  String
  earnedAt DateTime @default(now())

  // Métadonnées
  reason    String? // Raison d'obtention du badge
  isVisible Boolean @default(true) // L'utilisateur peut masquer ses badges

  @@unique([userId, badgeId])
  @@index([userId])
  @@index([badgeId])
  @@index([earnedAt])
  @@map("user_badge")
}

// ============================================================
//                        RGPD AMÉLIORÉ
// ============================================================

model UserConsent {
  id     String @id @default(cuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Consentements détaillés
  cookies         Boolean @default(false)
  analytics       Boolean @default(false)
  marketing       Boolean @default(false)
  personalization Boolean @default(false) // Personnalisation
  communication   Boolean @default(false) // Communications

  // Métadonnées améliorées
  consentDate    DateTime      @default(now())
  consentVersion String        @default("1.0") // Version de la politique
  ipAddress      String?
  userAgent      String?
  source         ConsentSource @default(BANNER) // Source du consentement

  // Gestion des retraits
  withdrawnAt    DateTime?
  withdrawReason String?

  // Historique enrichi (JSON pour MVP)
  history Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([consentDate])
  @@map("user_consents")
}

model GDPRRequest {
  id     String  @id @default(cuid())
  userId String? // Peut être null si utilisateur supprimé
  user   User?   @relation(fields: [userId], references: [id], onDelete: SetNull)

  // Informations de base enrichies
  type      GDPRType
  email     String
  firstName String?
  lastName  String?
  phone     String?
  status    RequestStatus   @default(PENDING)
  priority  RequestPriority @default(NORMAL)

  // Contenu détaillé
  subject     String?
  message     String
  attachments String[] // URLs des pièces jointes
  response    String?

  // Traitement
  assignedTo    String? // ID de l'admin assigné
  processedBy   String? // ID de l'admin qui a traité
  internalNotes String? // Notes internes

  // Dates et délais
  requestDate   DateTime  @default(now())
  dueDate       DateTime? // Date limite légale (30 jours)
  processedDate DateTime?
  reminderSent  Boolean   @default(false)

  // Métadonnées
  ipAddress String?
  userAgent String?
  source    RequestSource @default(WEB_FORM)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([email])
  @@index([status])
  @@index([type])
  @@index([requestDate])
  @@index([dueDate])
  @@map("gdpr_requests")
}

// ============================================================
//                        CONTENU (NOUVEAU)
// ============================================================

model Post {
  id          String    @id @default(cuid())
  title       String
  slug        String    @unique
  content     String?   @db.Text // Type TEXT pour le contenu long
  excerpt     String?
  published   Boolean   @default(false)
  publishedAt DateTime?

  // Relations
  authorId   String
  author     User      @relation(fields: [authorId], references: [id], onDelete: Cascade)
  categoryId String?
  category   Category? @relation(fields: [categoryId], references: [id], onDelete: SetNull)
  tags       PostTag[]
  views      PostView[]

  // Image de couverture
  coverImage String?

  // SEO amélioré
  metaTitle       String?
  metaDescription String? @db.VarChar(160) // Limite SEO
  ogImage         String?
  canonicalUrl    String?

  // Statistiques
  viewCount    Int @default(0)
  likeCount    Int @default(0)
  commentCount Int @default(0)

  // Modération
  status          PostStatus @default(DRAFT)
  moderatedBy     String?
  moderatedAt     DateTime?
  moderationNotes String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([slug])
  @@index([authorId])
  @@index([published])
  @@index([status])
  @@index([publishedAt])
  @@index([createdAt])
  @@map("posts")
}

model Category {
  id          String     @id @default(cuid())
  name        String
  slug        String     @unique
  description String?
  color       String?    @default("#6B7280")
  parentId    String?
  parent      Category?  @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children    Category[] @relation("CategoryHierarchy")
  posts       Post[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([slug])
  @@index([parentId])
  @@map("categories")
}

model Tag {
  id    String    @id @default(cuid())
  name  String    @unique
  slug  String    @unique
  color String?   @default("#8B5CF6")
  posts PostTag[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([slug])
  @@map("tags")
}

model PostTag {
  id     String @id @default(cuid())
  post   Post   @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId String
  tag    Tag    @relation(fields: [tagId], references: [id], onDelete: Cascade)
  tagId  String

  @@unique([postId, tagId])
  @@index([postId])
  @@index([tagId])
  @@map("post_tags")
}

model PostView {
  id        String   @id @default(cuid())
  postId    String
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  
  // Informations de tracking
  ipAddress String
  userAgent String   @default("")
  referer   String   @default("")
  
  // Géolocalisation (optionnel)
  country   String?
  region    String?
  city      String?
  
  createdAt DateTime @default(now())

  @@index([postId])
  @@index([ipAddress])
  @@index([createdAt])
  @@map("post_views")
}

// ============================================================
//                    ÉTAPE 1 : PLACES CORE (MVP)
// ============================================================

model Place {
  id          String    @id @default(cuid())
  name        String
  slug        String    @unique
  type        PlaceType
  category    String? // Sous-catégorie libre pour flexibilité (deprecated, use categories relation)
  description String?   @db.Text
  summary     String?   @db.VarChar(280) // Pour partage Twitter

  // Statut
  status     PlaceStatus @default(DRAFT)
  isVerified Boolean     @default(false)
  isActive   Boolean     @default(true)
  isFeatured Boolean     @default(false)

  // Google Business Integration
  googlePlaceId      String?   @unique // Place ID de Google
  googleMapsUrl      String? // URL Google Maps
  googleBusinessData Json? // Données cachées de Google My Business
  lastGoogleSync     DateTime? // Dernière synchro

  // Propriétaire
  ownerId   String?
  owner     User?     @relation("PlaceOwner", fields: [ownerId], references: [id], onDelete: SetNull)
  claimedAt DateTime? // Date de revendication

  // Contact principal
  email   String?
  phone   String?
  website String?

  // Localisation (requis pour Google Places)
  street       String
  streetNumber String?
  postalCode   String
  city         String
  latitude     Float?
  longitude    Float?

  // Réseaux sociaux pour partage
  facebook  String?
  instagram String?
  twitter   String?
  linkedin  String?
  tiktok    String?

  // Médias
  logo       String?
  coverImage String?
  images     Json? // ["url1", "url2"] pour MVP

  // SEO & Partage social
  metaTitle       String? @db.VarChar(60)
  metaDescription String? @db.VarChar(160)
  ogImage         String? // Image pour partage réseaux sociaux

  // Statistiques
  viewCount   Int    @default(0)
  shareCount  Int    @default(0)
  rating      Float? @default(0)
  reviewCount Int    @default(0)

  // Relations MVP
  openingHours  OpeningHours[]
  reviews       Review[]
  googleReviews GoogleReview[]
  favorites     Favorite[]
  claims        PlaceClaim[]
  categories    PlaceToCategory[] // Many-to-many avec PlaceCategory
  events        Event[] // Événements organisés dans cette place

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([slug])
  @@index([type])
  @@index([status])
  @@index([googlePlaceId])
  @@index([postalCode, city])
  @@index([latitude, longitude])
  @@map("places")
}

// ============================================================
//                    CATÉGORIES DE PLACES
// ============================================================

model PlaceCategory {
  id          String  @id @default(cuid())
  name        String  @unique
  slug        String  @unique
  description String? @db.Text
  
  // Apparence visuelle
  icon        String? // Nom de l'icône Lucide ou emoji
  color       String? @default("#6B7280") // Couleur hexadécimale
  bgColor     String? @default("bg-gray-100") // Classe Tailwind background
  textColor   String? @default("text-gray-700") // Classe Tailwind texte
  borderColor String? @default("border-gray-200") // Classe Tailwind bordure
  
  // Configuration
  isActive    Boolean @default(true)
  sortOrder   Int     @default(0) // Pour l'ordre d'affichage
  
  // Métadonnées
  placeCount  Int     @default(0) // Cache du nombre de places
  
  // Relations hiérarchiques
  parentId    String?
  parent      PlaceCategory? @relation("PlaceCategoryHierarchy", fields: [parentId], references: [id])
  children    PlaceCategory[] @relation("PlaceCategoryHierarchy")
  
  // Relations avec places
  places      PlaceToCategory[] // Many-to-many avec Place
  
  // Timestamps
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([slug])
  @@index([parentId])
  @@index([isActive])
  @@index([sortOrder])
  @@map("place_categories")
}

// Table de liaison pour la relation many-to-many Place <-> PlaceCategory
model PlaceToCategory {
  id         String        @id @default(cuid())
  placeId    String
  categoryId String
  
  place      Place         @relation(fields: [placeId], references: [id], onDelete: Cascade)
  category   PlaceCategory @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  
  createdAt  DateTime      @default(now())
  
  @@unique([placeId, categoryId])
  @@index([placeId])
  @@index([categoryId])
  @@map("place_to_categories")
}

// ============================================================
//                    HORAIRES D'OUVERTURE
// ============================================================

model OpeningHours {
  id      String @id @default(cuid())
  placeId String
  place   Place  @relation(fields: [placeId], references: [id], onDelete: Cascade)

  dayOfWeek DayOfWeek
  openTime  String? // Format "HH:MM"
  closeTime String? // Format "HH:MM"
  isClosed  Boolean   @default(false)

  @@index([placeId, dayOfWeek])
  @@map("opening_hours")
}

// ============================================================
//                    AVIS GOOGLE-LIKE
// ============================================================

model Review {
  id      String @id @default(cuid())
  placeId String
  place   Place  @relation(fields: [placeId], references: [id], onDelete: Cascade)
  userId  String
  user    User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  rating  Int // 1-5 étoiles
  comment String? @db.Text

  // Import Google Reviews
  googleReviewId String? @unique
  isGoogleReview Boolean @default(false)

  // Réponse propriétaire
  response    String?   @db.Text
  respondedAt DateTime?

  status ReviewStatus @default(PENDING)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([placeId, userId])
  @@index([placeId])
  @@index([userId])
  @@index([rating])
  @@map("reviews")
}

// ============================================================
//                    AVIS GOOGLE IMPORTÉS
// ============================================================

model GoogleReview {
  id      String @id @default(cuid())
  placeId String
  place   Place  @relation(fields: [placeId], references: [id], onDelete: Cascade)

  rating  Int // 1-5 étoiles
  comment String? @db.Text

  // Informations Google
  googleReviewId String  @unique
  authorName     String
  authorUrl      String?
  googleTime     Int     // Timestamp Google
  relativeTime   String? // "il y a 2 mois"

  // Réponse propriétaire
  response    String?   @db.Text
  respondedAt DateTime?

  status ReviewStatus @default(APPROVED) // Les avis Google sont automatiquement approuvés

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([placeId])
  @@index([rating])
  @@index([googleReviewId])
  @@map("google_reviews")
}

// ============================================================
//                    FAVORIS UTILISATEURS
// ============================================================

model Favorite {
  id      String @id @default(cuid())
  userId  String
  user    User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  placeId String
  place   Place  @relation(fields: [placeId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([userId, placeId])
  @@index([userId])
  @@index([placeId])
  @@map("favorites")
}

// ============================================================
//                    REVENDICATIONS DE PLACES
// ============================================================

model PlaceClaim {
  id      String @id @default(cuid())
  placeId String
  place   Place  @relation(fields: [placeId], references: [id], onDelete: Cascade)
  userId  String
  user    User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  message String      @db.Text // Message de revendication
  proof   String? // URL vers une preuve (document, photo, etc.)
  status  ClaimStatus @default(PENDING)

  // Admin qui traite la demande
  processedBy  String?
  processedAt  DateTime?
  adminMessage String? // Message de l'admin lors du traitement

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([placeId])
  @@index([userId])
  @@index([status])
  @@map("place_claims")
}

// ============================================================
//                        ENUMS AMÉLIORÉS
// ============================================================

enum Role {
  user
  admin
  moderator
  dpo // Data Protection Officer
  editor // Éditeur de contenu
}

enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
  BANNED
  PENDING_VERIFICATION
  DELETED
}

enum Theme {
  LIGHT
  DARK
  SYSTEM
}

enum VerificationType {
  EMAIL
  PHONE
  PASSWORD_RESET
  TWO_FACTOR
}

enum BadgeCategory {
  GENERAL
  ACHIEVEMENT
  PARTICIPATION
  SPECIAL
  ANNIVERSARY
}

enum BadgeRarity {
  COMMON
  UNCOMMON
  RARE
  EPIC
  LEGENDARY
}

enum ConsentSource {
  BANNER
  SETTINGS
  REGISTRATION
  API
  MIGRATION
}

enum GDPRType {
  DATA_EXPORT // Art. 15 - Droit d'accès
  DATA_DELETE // Art. 17 - Droit à l'effacement
  DATA_CORRECT // Art. 16 - Droit de rectification
  DATA_RESTRICT // Art. 18 - Droit à la limitation
  DATA_PORTABLE // Art. 20 - Droit à la portabilité
  OBJECTION // Art. 21 - Droit d'opposition
  COMPLAINT // Plainte
  CONSENT_WITHDRAW // Retrait de consentement
  OTHER
}

enum RequestStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  REJECTED
  EXPIRED
  CANCELLED
}

enum RequestPriority {
  LOW
  NORMAL
  HIGH
  URGENT
}

enum RequestSource {
  WEB_FORM
  EMAIL
  PHONE
  CHAT
  API
  ADMIN_PANEL
}

enum PostStatus {
  DRAFT
  PENDING_REVIEW
  PUBLISHED
  ARCHIVED
  REJECTED
}

enum PlaceType {
  COMMERCE
  SERVICE
  RESTAURANT
  ARTISAN
  ADMINISTRATION
  MUSEUM
  TOURISM
  PARK
  LEISURE
  ASSOCIATION
  HEALTH
  EDUCATION
  TRANSPORT
  ACCOMMODATION
  OTHER
}

enum PlaceStatus {
  DRAFT
  PENDING
  ACTIVE
  INACTIVE
  CLOSED
}

enum DayOfWeek {
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
  SUNDAY
}

enum ReviewStatus {
  PENDING
  APPROVED
  REJECTED
}

enum ClaimStatus {
  PENDING
  APPROVED
  REJECTED
}

// ============================================================
//                    ÉVÉNEMENTS ET AGENDA
// ============================================================

model Event {
  id          String @id @default(cuid())
  title       String
  slug        String @unique
  description String? @db.Text
  summary     String? @db.VarChar(280) // Résumé court pour partage social

  // Statut et visibilité
  status      EventStatus @default(DRAFT)
  isPublished Boolean     @default(false)
  isFeatured  Boolean     @default(false)
  isActive    Boolean     @default(true)

  // Organisateur
  organizerId String?
  organizer   User?  @relation("EventOrganizer", fields: [organizerId], references: [id], onDelete: SetNull)
  
  // Place associée (optionnel)
  placeId     String?
  place       Place?  @relation(fields: [placeId], references: [id], onDelete: SetNull)

  // Contact événement
  email       String?
  phone       String?
  website     String?
  ticketUrl   String? // URL de billetterie

  // Dates et récurrence
  startDate   DateTime
  endDate     DateTime
  isAllDay    Boolean @default(false)
  timezone    String  @default("Europe/Paris")
  
  // Récurrence
  isRecurring     Boolean           @default(false)
  recurrenceRule  RecurrenceRule?   @relation(fields: [recurrenceRuleId], references: [id])
  recurrenceRuleId String?          @unique
  parentEventId   String?          // Pour les instances d'événements récurrents
  parentEvent     Event?           @relation("EventRecurrence", fields: [parentEventId], references: [id])
  instances       Event[]          @relation("EventRecurrence")

  // Localisation (si différent de la place)
  locationName     String?
  locationAddress  String?
  locationCity     String?
  locationLatitude Float?
  locationLongitude Float?

  // Capacité et participants
  maxParticipants  Int?
  currentParticipants Int @default(0)
  waitingList      Boolean @default(false)

  // Tarification
  isFree           Boolean @default(true)
  price            Float?
  priceDetails     String? // "Adulte: 15€, Enfant: 8€"
  currency         String  @default("EUR")

  // Médias
  logo             String?
  coverImage       String?
  images           Json?   // ["url1", "url2"] pour galerie
  videos           Json?   // URLs de vidéos

  // SEO et partage social
  metaTitle        String? @db.VarChar(60)
  metaDescription  String? @db.VarChar(160)
  ogImage          String?

  // Réseaux sociaux
  facebook         String?
  instagram        String?
  twitter          String?
  linkedin         String?
  tiktok           String?
  
  // Tags et catégories
  tags             Json?   // ["musique", "concert"] pour MVP
  category         EventCategory?

  // Statistiques
  viewCount        Int     @default(0)
  shareCount       Int     @default(0)
  participantCount Int     @default(0)

  // Relations
  participants     EventParticipant[]
  reminders        EventReminder[]

  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  @@index([slug])
  @@index([status])
  @@index([isPublished])
  @@index([startDate])
  @@index([endDate])
  @@index([organizerId])
  @@index([placeId])
  @@index([category])
  @@index([locationCity])
  @@map("events")
}

// Règles de récurrence pour les événements
model RecurrenceRule {
  id       String @id @default(cuid())
  
  // Type de récurrence
  frequency    RecurrenceFrequency // DAILY, WEEKLY, MONTHLY, YEARLY
  interval     Int                 @default(1) // Tous les X jours/semaines/mois
  count        Int?                // Nombre d'occurrences (optionnel)
  until        DateTime?           // Date de fin (optionnel)
  
  // Jours de la semaine (pour récurrence hebdomadaire)
  byWeekDay    Json?              // [1,3,5] pour lundi, mercredi, vendredi
  
  // Jours du mois (pour récurrence mensuelle)
  byMonthDay   Json?              // [1,15] pour le 1er et 15 du mois
  
  // Mois de l'année (pour récurrence annuelle)  
  byMonth      Json?              // [6,12] pour juin et décembre
  
  // Exceptions (dates à exclure)
  exceptions   Json?              // ["2024-12-25", "2024-01-01"]

  // Configuration avancée
  workdaysOnly Boolean @default(false) // Exclure weekends
  
  event        Event?
  
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  
  @@map("recurrence_rules")
}

// Participants aux événements
model EventParticipant {
  id          String @id @default(cuid())
  eventId     String
  event       Event  @relation(fields: [eventId], references: [id], onDelete: Cascade)
  userId      String
  user        User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  status      ParticipationStatus @default(INTERESTED)
  registeredAt DateTime           @default(now())
  
  // Informations supplémentaires
  guestCount   Int     @default(0) // Nombre d'accompagnants
  specialNeeds String? // Besoins spéciaux, allergies, etc.
  notes        String? // Notes personnelles
  
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  
  @@unique([eventId, userId])
  @@index([eventId])
  @@index([userId])
  @@index([status])
  @@map("event_participants")
}

// Rappels d'événements
model EventReminder {
  id       String @id @default(cuid())
  eventId  String
  event    Event  @relation(fields: [eventId], references: [id], onDelete: Cascade)
  userId   String
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  reminderTime DateTime // Quand envoyer le rappel
  type         ReminderType
  sent         Boolean   @default(false)
  sentAt       DateTime?
  
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  
  @@unique([eventId, userId, reminderTime])
  @@index([eventId])
  @@index([userId])
  @@index([reminderTime])
  @@index([sent])
  @@map("event_reminders")
}

// ============================================================
//                    NOUVEAUX ENUMS POUR ÉVÉNEMENTS
// ============================================================

enum EventStatus {
  DRAFT
  PENDING_REVIEW
  PUBLISHED
  CANCELLED
  POSTPONED
  COMPLETED
  ARCHIVED
}

enum EventCategory {
  CONFERENCE
  CONCERT
  FESTIVAL
  WORKSHOP
  SEMINAR
  EXHIBITION
  SPORT
  CULTURAL
  SOCIAL
  BUSINESS
  EDUCATIONAL
  ENTERTAINMENT
  CHARITY
  RELIGIOUS
  POLITICAL
  FAMILY
  FOOD
  HEALTH
  TECHNOLOGY
  ART
  MUSIC
  THEATER
  CINEMA
  BOOK
  NATURE
  TOURISM
  OTHER
}

enum RecurrenceFrequency {
  DAILY
  WEEKLY
  MONTHLY
  YEARLY
}

enum ParticipationStatus {
  INTERESTED
  GOING
  MAYBE
  NOT_GOING
  CANCELLED
  WAITLISTED
}

enum ReminderType {
  EMAIL
  PUSH
  SMS
}

// ============================================================
//                    NEWSLETTER SYSTEM
// ============================================================

model NewsletterSubscriber {
  id          String @id @default(cuid())
  email       String @unique
  firstName   String?
  lastName    String?
  
  // Préférences d'abonnement
  preferences NewsletterPreferences?
  
  // Statut
  isActive    Boolean   @default(true)
  isVerified  Boolean   @default(false)
  verificationToken String? @unique
  unsubscribeToken  String? @unique
  
  // Métadonnées
  subscribedAt DateTime @default(now())
  lastEmailSent DateTime?
  
  // Relations
  campaigns   NewsletterCampaignSent[]
  queueJobs   NewsletterQueue[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@map("newsletter_subscribers")
}

model NewsletterPreferences {
  id          String @id @default(cuid())
  subscriberId String @unique
  subscriber  NewsletterSubscriber @relation(fields: [subscriberId], references: [id], onDelete: Cascade)
  
  // Types de contenus
  events      Boolean @default(true)   // Événements et animations
  places      Boolean @default(true)   // Nouveaux commerces
  offers      Boolean @default(false)  // Offres et promotions
  news        Boolean @default(true)   // Actualités association
  
  // Fréquence
  frequency   NewsletterFrequency @default(WEEKLY)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@map("newsletter_preferences")
}

model NewsletterCampaign {
  id          String @id @default(cuid())
  title       String
  subject     String
  content     String @db.Text
  
  // Configuration
  type        NewsletterType @default(NEWSLETTER)
  status      CampaignStatus @default(DRAFT)
  
  // Planification
  scheduledAt DateTime?
  sentAt      DateTime?
  
  // Contenu sélectionné
  includedEvents  String[] // IDs des événements
  includedPlaces  String[] // IDs des places
  includedPosts   String[] // IDs des posts
  
  // Statistiques
  totalRecipients     Int @default(0)
  totalSent          Int @default(0)
  totalDelivered     Int @default(0)
  totalOpened        Int @default(0)
  totalClicked       Int @default(0)
  totalUnsubscribed  Int @default(0)
  
  // Relations
  sentCampaigns NewsletterCampaignSent[]
  attachments   NewsletterAttachment[]
  queueJobs     NewsletterQueue[]
  
  // Métadonnées
  createdById String
  createdBy   User   @relation(fields: [createdById], references: [id])
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@map("newsletter_campaigns")
}

model NewsletterCampaignSent {
  id           String @id @default(cuid())
  campaignId   String
  campaign     NewsletterCampaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  subscriberId String
  subscriber   NewsletterSubscriber @relation(fields: [subscriberId], references: [id], onDelete: Cascade)
  
  // Statut de l'envoi
  status       EmailStatus @default(PENDING)
  sentAt       DateTime?
  deliveredAt  DateTime?
  openedAt     DateTime?
  clickedAt    DateTime?
  unsubscribedAt DateTime?
  
  // Métadonnées de l'email
  messageId    String?
  errorMessage String?
  
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  
  @@unique([campaignId, subscriberId])
  @@map("newsletter_campaign_sent")
}

// ============================================================
//                    NEWSLETTER ENUMS
// ============================================================

enum NewsletterFrequency {
  DAILY
  WEEKLY
  MONTHLY
}

enum NewsletterType {
  NEWSLETTER      // Newsletter régulière
  ANNOUNCEMENT    // Annonce spéciale
  EVENT_DIGEST    // Digest d'événements
  PLACE_UPDATE    // Nouveaux commerces
  PROMOTIONAL     // Offres promotionnelles
}

enum CampaignStatus {
  DRAFT
  SCHEDULED
  SENDING
  SENT
  CANCELLED
  ERROR
}

enum EmailStatus {
  PENDING
  SENT
  DELIVERED
  OPENED
  CLICKED
  BOUNCED
  UNSUBSCRIBED
  ERROR
  FAILED
}

// ============================================================
//                NEWSLETTER ATTACHMENTS & QUEUE
// ============================================================

model NewsletterAttachment {
  id         String @id @default(cuid())
  campaignId String
  campaign   NewsletterCampaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  
  // Informations du fichier
  fileName     String
  originalName String
  fileType     String
  fileSize     Int    // en bytes
  filePath     String // chemin relatif depuis public/
  
  // Métadonnées
  uploadedBy   String
  uploader     User   @relation(fields: [uploadedBy], references: [id])
  
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  
  @@index([campaignId])
  @@map("newsletter_attachments")
}

model NewsletterQueue {
  id         String @id @default(cuid())
  campaignId String
  campaign   NewsletterCampaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  
  subscriberId String
  subscriber   NewsletterSubscriber @relation(fields: [subscriberId], references: [id], onDelete: Cascade)
  
  // Configuration de la tâche
  priority     Int @default(0)
  attempts     Int @default(0)
  maxAttempts  Int @default(3)
  
  // Planification
  scheduledAt  DateTime
  processedAt  DateTime?
  
  // Statut
  status       QueueStatus @default(PENDING)
  error        String?
  
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  
  @@index([status, scheduledAt])
  @@index([campaignId])
  @@index([subscriberId])
  @@map("newsletter_queue")
}

enum QueueStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}
